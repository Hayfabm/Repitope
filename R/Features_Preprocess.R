#' Preprocess peptide feature dataframes for machine learning.
#'
#' @param featureDFList A list of feature dataframes generated by \code{Features}.
#' @param metadataDFList A list of metadata dataframes labeled as "Peptide", "Immunogenicity", and "Cluster". No extra metadata is allowed. Feature dataframes are downsized based on the "Peptide" column in this metadata. In other words, peptides not contained in the metadata dataframe are omitted.
#' @param preprocessedDFList_reference A list of feature dataframes generated by \code{Features_Preprocess} for reference. Set \code{NULL} to omit.
#' @importFrom dplyr %>%
#' @importFrom dplyr distinct
#' @importFrom dplyr filter
#' @importFrom dplyr mutate
#' @importFrom dplyr left_join
#' @importFrom dplyr select
#' @importFrom tidyr drop_na
#' @importFrom stringr str_split
#' @importFrom stringr fixed
#' @importFrom rlang set_names
#' @importFrom tibble as_tibble
#' @importFrom DescTools Sort
#' @importFrom caret createDataPartition
#' @importFrom caret preProcess
#' @importFrom caret rfeControl
#' @importFrom caret rfFuncs
#' @importFrom caret rfe
#' @importFrom caret predictors
#' @importFrom parallel detectCores
#' @importFrom parallel splitIndices
#' @importFrom parallel detectCores
#' @importFrom parallel makeCluster
#' @importFrom parallel clusterEvalQ
#' @importFrom parallel clusterExport
#' @importFrom parallel stopCluster
#' @importFrom pbapply pbapply
#' @importFrom pbapply pblapply
#' @export
#' @rdname Features_Preprocess
#' @name Features_Preprocess
Features_Preprocess <- function(featureDFList, metadataDFList, preprocessedDFList_reference=NULL){
  # If preprocessing functions are already prepared
  if(!is.null(preprocessedDFList_reference)){
    paramDF <- expand.grid(names(metadataDFList), names(featureDFList), stringsAsFactors=F)
    conbinedParamSet <- apply(paramDF, 1, function(v){paste0(v, collapse=".")})
    if(length(conbinedParamSet)!=length(preprocessedDFList_reference)){
      message("length(preprocessedDFList_reference) must be equal to length(featureDFList)*length(metadataDFList) !")
      return(NULL)
    }
    preprocessedDFList <- pbapply::pblapply(1:length(preprocessedDFList_reference), function(i){
      featureSet_reference <- colnames(preprocessedDFList_reference[[i]][["df_train"]])
      pp <- preprocessedDFList_reference[[i]][["pp_train"]]
      f <- featureDFList[[paramDF[[2]][[i]]]]
      m <- featureDFList[[paramDF[[1]][[i]]]]
      d <- dplyr::left_join(m, f, by="Peptide") %>%
        tidyr::drop_na() %>%
        dplyr::mutate(Immunogenicity=factor(Immunogenicity, levels=c("Positive", "Negative")))
      d.pp <- dplyr::select(d, featureSet_reference)
      d.pp <- predict(pp, d.pp)
      return(d.pp)
    })
    names(preprocessedDFList) <- conbinedParamSet
    return(preprocessedDFList)
  }

  # Main preprocessing workflow
  time.start <- proc.time()

  # Installation check [for recursive feature elimination]
  is.installed <- function(mypkg){is.element(mypkg, installed.packages()[,1])}
  if(!is.installed("randomForest")){install.packages("randomForest")}

  # Splitting
  Features_Split_Single <- function(featureDF, metadataDF, seed=12345){
    # Combine metadata
    df <- dplyr::left_join(metadataDF, featureDF, by="Peptide") %>%
      tidyr::drop_na() %>%
      dplyr::mutate(Immunogenicity=factor(Immunogenicity, levels=c("Positive", "Negative")))

    # Randomly choose one epitope per each cluster [Minor class is prioritized]
    set.seed(seed)
    outcome_table <- table(df$"Immunogenicity")
    if(outcome_table["Positive"]>=outcome_table["Negative"]){
      outcome_minor_major <- c("Negative", "Positive")
    }else{
      outcome_minor_major <- c("Positive", "Negative")
    }
    df <- df %>%
      (function(d){d[sample.int(nrow(d)),]}) %>%
      dplyr::mutate(Immunogenicity=factor(Immunogenicity, levels=outcome_minor_major)) %>%
      dplyr::distinct(Immunogenicity, Cluster, .keep_all=T) %>%
      dplyr::distinct(Cluster, .keep_all=T) %>%
      dplyr::distinct(Peptide, .keep_all=T) %>%
      DescTools::Sort(ord=c("Peptide", "Cluster")) %>%
      dplyr::mutate(Immunogenicity=factor(Immunogenicity, levels=c("Positive", "Negative")))

    # Random data splitting
    set.seed(seed)
    trainID <- caret::createDataPartition(df$"Immunogenicity", p=7/10, list=F)
    df_train <- df[trainID,] ## Proportion == 0.7
    df_test <- df[-trainID,]
    testID <- caret::createDataPartition(df_test$"Immunogenicity", p=2/3, list=F)
    df_test <- df_test[testID,]   ## Proportion == 0.2
    df_valid <- df_test[-testID,] ## Proportion == 0.1

    # Output
    list("df"=df, "df_train"=df_train, "df_test"=df_test, "df_valid"=df_valid)
  }
  message("Splitting dataframes...")
  paramDF <- expand.grid(names(metadataDFList), names(featureDFList), stringsAsFactors=F)
  conbinedParamSet <- apply(paramDF, 1, function(v){paste0(v, collapse=".")})
  splitFeatureDFList <- pbapply::pbapply(
    paramDF, 1,
    function(v){
      s <- as.numeric(as.character(rev(unlist(stringr::str_split(v[[2]], stringr::fixed("."))))[1]))
      Features_Split_Single(featureDFList[[v[2]]], metadataDFList[[v[1]]], s)
    }
  )
  names(splitFeatureDFList) <- conbinedParamSet
  gc();gc()

  # Preprocessing
  caretSeeds <- function(seed, number){
    set.seed(seed)
    seeds <- vector(mode="list", length=number+1)
    for(i in 1:number) seeds[[i]] <- sample.int(10000, 2)
    seeds[[number+1]] <- sample.int(10000, 1)
    return(seeds)
  }
  message("Generating random seeds...")
  caretSeedsList <- pbapply::pblapply(
    conbinedParamSet,
    function(param){
      s <- as.numeric(as.character(rev(unlist(stringr::str_split(param, stringr::fixed("."))))[1]))
      caretSeeds(s, number=10)
    }
  )
  Features_Preprocess_Single <- function(splitFeatureDFList, seeds){
    # Data
    df_train <- splitFeatureDFList$"df_train"
    df_test <- splitFeatureDFList$"df_test"
    df_valid <- splitFeatureDFList$"df_valid"

    # Preprocessing [variance and correlation]
    df_train_features <- dplyr::select(df_train, -Peptide, -Immunogenicity, -Cluster)
    df_train_features <- predict(caret::preProcess(df_train_features, method=c("nzv", "corr"), verbose=T), df_train_features)
    featureSet <- colnames(df_train_features)
    featureSet_dummy <- grep("Peptide_", featureSet, value=T)
    pp_train <- caret::preProcess(dplyr::select(df_train_features, setdiff(featureSet, featureSet_dummy)), method=c("center", "scale"), verbose=T)

    df <- predict(pp_train, dplyr::select(df, Peptide, Immunogenicity, Cluster, featureSet))
    df_train <- predict(pp_train, dplyr::select(df_train, Peptide, Immunogenicity, Cluster, featureSet))
    df_test <- predict(pp_train, dplyr::select(df_test, Peptide, Immunogenicity, Cluster, featureSet))
    df_valid <- predict(pp_train, dplyr::select(df_valid, Peptide, Immunogenicity, Cluster, featureSet))

    # Recursive feature elimination
    df_train_outcomes <- df_train[["Immunogenicity"]]
    df_train_features <- dplyr::select(df_train, -Peptide, -Immunogenicity, -Cluster)
    rfeCtrl <- caret::rfeControl(functions=caret::rfFuncs, method="cv", number=10, verbose=T, seeds=seeds, allowParallel=T)
    rfeRes <- caret::rfe(df_train_features, df_train_outcomes, sizes=100, metric="Kappa", rfeControl=rfeCtrl)
    rfeFeatureSet <- caret::predictors(rfeRes)

    df <- dplyr::select(df, Peptide, Immunogenicity, Cluster, rfeFeatureSet)
    df_train <- dplyr::select(df_train, Peptide, Immunogenicity, Cluster, rfeFeatureSet)
    df_test <- dplyr::select(df_test, Peptide, Immunogenicity, Cluster, rfeFeatureSet)
    df_valid <- dplyr::select(df_valid, Peptide, Immunogenicity, Cluster, rfeFeatureSet)

    # Output
    list("df"=df, "df_train"=df_train, "df_test"=df_test, "df_valid"=df_valid, "rfeRes"=rfeRes, "pp_train"=pp_train)
  }

  ## Parallelization
  message("Preprocessing was started. (Memory occupied = ", memory.size(), "[Mb])")
  cl <- parallel::makeCluster(parallel::detectCores(), type="SOCK")
  invisible(parallel::clusterEvalQ(cl, {library(tidyverse); library(caret); library(randomForest)}))
  parallel::clusterExport(cl, list("Features_Preprocess_Single", "splitFeatureDFList", "caretSeedsList"), envir=environment())
  preprocessedDFList <- pbapply::pblapply(
    1:length(conbinedParamSet),
    function(i){Features_Preprocess_Single(splitFeatureDFList[[i]], caretSeedsList[[i]])},
    cl=cl
  )
  names(preprocessedDFList) <- conbinedParamSet
  parallel::stopCluster(cl)
  message("Preprocessing was finished. (Memory occupied = ", memory.size(), "[Mb])")
  gc();gc()

  # Output
  time.end <- proc.time()
  message("Overall time required = ", format((time.end-time.start)[3], nsmall=2), "[sec]")
  return(preprocessedDFList)
}
