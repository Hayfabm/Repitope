#' Preprocess peptide feature dataframes for machine learning.
#'
#' @param featureDFList A list of feature dataframes generated by \code{Features}.
#' @param metadataDF A metadata dataframe labeled as "Peptide", "Immunogenicity", and "Cluster". No extra metadata is allowed. Feature dataframes are downsized based on the "Peptide" column in this metadata. In other words, peptides not contained in the metadata dataframe are omitted.
#' @importFrom dplyr %>%
#' @importFrom dplyr distinct
#' @importFrom dplyr filter
#' @importFrom dplyr mutate
#' @importFrom dplyr left_join
#' @importFrom dplyr select
#' @importFrom tidyr drop_na
#' @importFrom stringr str_split
#' @importFrom stringr fixed
#' @importFrom rlang set_names
#' @importFrom tibble as_tibble
#' @importFrom DescTools Sort
#' @importFrom caret createDataPartition
#' @importFrom caret preProcess
#' @importFrom caret rfeControl
#' @importFrom caret rfFuncs
#' @importFrom caret rfe
#' @importFrom caret predictors
#' @importFrom parallel detectCores
#' @importFrom parallel splitIndices
#' @importFrom parallel detectCores
#' @importFrom parallel makeCluster
#' @importFrom parallel clusterEvalQ
#' @importFrom parallel clusterExport
#' @importFrom parallel stopCluster
#' @export
#' @rdname Features_Preprocess
#' @name Features_Preprocess
Features_Preprocess <- function(featureDFList, metadataDF){
  # Working function
  Features_Preprocess_Single <- function(featureDF, metadataDF, seed=12345){
    # Combine metadata
    df <- dplyr::left_join(metadataDF, featureDF, by="Peptide") %>%
      tidyr::drop_na() %>%
      dplyr::mutate(Immunogenicity=factor(Immunogenicity, levels=c("Positive", "Negative")))

    # Randomly choose one epitope per each cluster [Minor class is prioritized]
    set.seed(seed)
    outcome_table <- table(df$"Immunogenicity")
    if(outcome_table["Positive"]>=outcome_table["Negative"]){
      outcome_minor_major <- c("Negative", "Positive")
    }else{
      outcome_minor_major <- c("Positive", "Negative")
    }
    df <- df %>%
      (function(d){d[sample.int(nrow(d)),]}) %>%
      dplyr::mutate(Immunogenicity=factor(Immunogenicity, levels=outcome_minor_major)) %>%
      dplyr::distinct(Immunogenicity, Cluster, .keep_all=T) %>%
      dplyr::distinct(Cluster, .keep_all=T) %>%
      dplyr::distinct(Peptide, .keep_all=T) %>%
      DescTools::Sort(ord=c("Peptide", "Cluster")) %>%
      dplyr::mutate(Immunogenicity=factor(Immunogenicity, levels=c("Positive", "Negative")))

    # Random data splitting
    set.seed(seed)
    trainID <- caret::createDataPartition(df$"Immunogenicity", p=7/10, list=F)
    df_train <- df[trainID,] ## Proportion == 0.7
    df_test <- df[-trainID,]
    testID <- caret::createDataPartition(df_test$"Immunogenicity", p=2/3, list=F)
    df_test <- df_test[testID,]   ## Proportion == 0.2
    df_valid <- df_test[-testID,] ## Proportion == 0.1

    # Pre-processing [Feature elimination based on variance and correlation, followed by normalization]
    cat("Feature elimination based on variance and correlation, followed by normalization.\n")
    df_train_features <- dplyr::select(df_train, -Peptide, -Immunogenicity, -Cluster)
    df_train_features <- predict(caret::preProcess(df_train_features, method=c("nzv", "corr"), verbose=T), df_train_features)
    featureSet <- colnames(df_train_features)
    featureSet_dummy <- grep("Peptide_", featureSet, value=T)
    pp_train <- caret::preProcess(dplyr::select(df_train_features, setdiff(featureSet, featureSet_dummy)), method=c("center", "scale"), verbose=T)

    df <- predict(pp_train, dplyr::select(df, Peptide, Immunogenicity, Cluster, featureSet))
    df_train <- predict(pp_train, dplyr::select(df_train, Peptide, Immunogenicity, Cluster, featureSet))
    df_test <- predict(pp_train, dplyr::select(df_test, Peptide, Immunogenicity, Cluster, featureSet))
    df_valid <- predict(pp_train, dplyr::select(df_valid, Peptide, Immunogenicity, Cluster, featureSet))

    # Recursive feature elimination
    is.installed <- function(mypkg){is.element(mypkg, installed.packages()[,1])}
    if(!is.installed("randomForest")){install.packages("randomForest")}
    cat("Recursive feature elimination.\n")
    set.seed(seed)
    seeds <- vector(mode="list", length=11)
    for(i in 1:10) seeds[[i]] <- sample.int(10000, 2)
    seeds[[11]] <- sample.int(10000, 1)
    df_train_outcomes <- df_train[["Immunogenicity"]]
    df_train_features <- dplyr::select(df_train, -Peptide, -Immunogenicity, -Cluster)
    rfeCtrl <- caret::rfeControl(functions=caret::rfFuncs, method="cv", number=10, verbose=T, seeds=seeds, allowParallel=T)
    cl <- parallel::makeCluster(parallel::detectCores(), type="SOCK")
    invisible(parallel::clusterEvalQ(cl, {library(caret); library(randomForest)}))
    parallel::clusterExport(cl, list("df_train_features", "df_train_outcomes", "rfeCtrl"), envir=environment())
    rfeRes <- caret::rfe(df_train_features, df_train_outcomes, sizes=100, metric="Kappa", rfeControl=rfeCtrl)
    rfeFeatureSet <- caret::predictors(rfeRes)
    print(rfeRes)
    parallel::stopCluster(cl)

    df <- dplyr::select(df, Peptide, Immunogenicity, Cluster, rfeFeatureSet)
    df_train <- dplyr::select(df_train, Peptide, Immunogenicity, Cluster, rfeFeatureSet)
    df_test <- dplyr::select(df_test, Peptide, Immunogenicity, Cluster, rfeFeatureSet)
    df_valid <- dplyr::select(df_valid, Peptide, Immunogenicity, Cluster, rfeFeatureSet)

    # Output
    list("df"=df, "df_train"=df_train, "df_test"=df_test, "df_valid"=df_valid, "rfeRes"=rfeRes, "pp_train"=pp_train)
  }

  # Batch preprocessing
  params <- as.data.frame(stringr::str_split(names(featureDFList), stringr::fixed("."), simplify=T), stringsAsFactors=F)
  seedSet <- as.numeric(as.character(params[[rev(colnames(params))[1]]]))
  l <- length(featureDFList)
  resList <- lapply(1:l, function(i){
    time.start <- proc.time()
    message("Parameter set ", i, "/", l, ": ", names(featureDFList)[[i]])
    res <- Features_Preprocess_Single(featureDFList[[i]], metadataDF, seed=seedSet[[i]])
    time.end <- proc.time()
    message("Overall time required = ", format((time.end-time.start)[3], nsmall=2), "[sec]")
    return(res)
  })
  items <- names(resList[[1]])
  resList <- lapply(items, function(item){
    res <- lapply(1:l, function(i){resList[[i]][[item]]})
    names(res) <- names(featureDFList)
  })
  names(resList) <- items
  return(tibble::as_tibble(resList))
}
