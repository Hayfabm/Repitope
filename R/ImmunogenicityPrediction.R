#' Immunogenicity prediction using H2O AutoML instances
#'
#' \code{Immunogenicity} is a wrapper function.\cr
#' \code{Immunogenicity_AutoML} conducts automated machine learning and exports the best H2O binary model.\cr
#' \code{Immunogenicity_Prediction} makes predictions using the previously exported model.
#'
#' @param preprocessedDFList An output generated by \code{Features_Preprocess} or \code{Features_FeatureSelection}. A nested list for batch processing is allowed.
#' @param trainDF A dataframe for model training.
#' @param testDF A dataframe for hold-out validation.
#' @param validDF A dataframe for leaderboard scoring.
#' @param evalDF A dataframe for evaluation.
#' @param featureSet A set of features to be used for model training. If "all", all features in the training dataframe except "DataType", "Immunogenicity", "Peptide", and "Cluster" will be used.
#' @param destDir A directory either from importing H2O models or for exporting outputs.
#' @param outputHeader A file/folder name header.
#' @param LeaderBoardName The file name of the leader board to be exported. The file format must be CSV. If you want to skip exporting, set \code{NULL}.
#' @param H2OModelName The file name of the best H2O model to be exported. No file extension is required. If you want to skip exporting, set \code{NULL}.
#' @param PredictionHeader The file name header of the prediction results to be exported.
#' @param seed A random seed.
#' @param max_mem_size The upper limit of memory for H2O Java machine learning engine.
#' @param nthreads The number of threads for H2O Java machine learning engine.
#' @importFrom dplyr %>%
#' @importFrom dplyr select
#' @importFrom dplyr mutate
#' @importFrom dplyr bind_cols
#' @importFrom readr write_csv
#' @importFrom stringr str_split
#' @importFrom stringr fixed
#' @importFrom data.table :=
#' @importFrom data.table as.data.table
#' @importFrom data.table rbindlist
#' @importFrom fst write.fst
#' @importFrom caret downSample
#' @importFrom caret createDataPartition
#' @importFrom pROC coords
#' @importFrom pROC roc
#' @importFrom classifierplots roc_plot
#' @importFrom classifierplots calibration_plot
#' @importFrom plotUtility theme_Publication
#' @importFrom plotUtility savePDF
#' @import h2o
#' @import ggplot2
#' @export
#' @rdname ImmunogenicityPrediction
#' @name ImmunogenicityPrediction
Immunogenicity <- function(
  preprocessedDFList, featureSet="all", destDir="./Results/", outputHeader="Output_", max_mem_size="6G", nthreads=6
){
  # Create directory (optional)
  dir.create(destDir, showWarnings=F, recursive=T)

  # Input check
  list.depth <- function(this, thisdepth=0) {  ## http://stackoverflow.com/a/13433689/1270695
    if(!is.list(this)){
      return(thisdepth)
    }else{
      return(max(unlist(lapply(this, list.depth, thisdepth=thisdepth+1))))
    }
  }
  depth <- list.depth(preprocessedDFList)
  if(depth==1) preprocessedDFList <- list("FirstElement"=preprocessedDFList)

  # Batch analysis
  leng <- length(preprocessedDFList)
  df_lb_list <- as.list(rep(NA, leng))
  df_pred_train_list <- as.list(rep(NA, leng))
  df_pred_test_list <- as.list(rep(NA, leng))
  df_pred_valid_list <- as.list(rep(NA, leng))
  cat("Number of datasets = ", leng, "\n", sep="")

  for(i in 1:leng){
    ## Input check
    dt <- preprocessedDFList[[i]]$"dt"
    if(!any(class(dt)=="data.table")) dt <- data.table::as.data.table(dt)
    if(is.null(dt$"DataType")){
      message("The input datatable is not valid! No 'DataType' column is detected.")
      return(NULL)
    }

    ## Define a random seed
    param <- names(preprocessedDFList)[i]
    s <- try(as.integer(rev(unlist(stringr::str_split(param, stringr::fixed("."))))[1]), silent=T)
    if(any(class(s)=="try-error")) s <- 123456789  ## ad hoc seed
    modName <- paste0("BestH2OModel_", param)
    modDir <- paste0(destDir, "/", outputHeader, param)
    dir.create(modDir, showWarnings=F, recursive=T)
    cat("Random seed = ", s, "\n", sep="")

    ## Partition testing and validation subdatasets (optional)
    if(identical(levels(dt$"DataType"), c("Train", "Test", "Valid"))){
      fst::write.fst(dt, file.path(modDir, paste0("Data_", param, ".fst")), compress=100)
    }else if(identical(levels(dt$"DataType"), c("Train", "Test"))){
      cat("Test data was further devided into subdatasets... Testing:Validation=2:1", "\n", sep="")
      testID <- caret::createDataPartition(dt[DataType=="Test", Immunogenicity], p=2/3, list=F)
      dt <- data.table::rbindlist(list(
        dt[DataType=="Train",],
        dt[DataType=="Test",][testID,],
        dt[DataType=="Test",][-testID,][,DataType:="Valid"]
      ))
      fst::write.fst(dt, file.path(modDir, paste0("Data_", param, ".fst")), compress=100)
    }else{
      message("The input datatable is not valid! 'DataType' must be one of the followings: Train, Test, Valid.")
      return(NULL)
    }

    ## Model training
    skipQ <- file.exists(file.path(modDir, modName))
    if(skipQ==F){
      cat("Initiating H2O AutoML...\n", sep="")
      df_lb_list[[i]] <- Immunogenicity_AutoML(
        dt[DataType=="Train",], dt[DataType=="Test",], dt[DataType=="Valid",],
        featureSet=featureSet,
        destDir=modDir, LeaderBoardName=NULL, H2OModelName=modName,
        seed=s, max_mem_size=max_mem_size, nthreads=nthreads
      ) %>% dplyr::mutate("Parameter"=param, "Seed"=s)
    }else{
      cat("Model training was skipped.\n")
    }

    ## Prediction
    cat("Immunogenicity predictions...\n", sep="")
    cat("Training data. \n", sep="")
    df_pred_train_list[[i]] <- Immunogenicity_Prediction(
      dt[DataType=="Train",],
      destDir=modDir, H2OModelName=modName, PredictionHeader=paste0("Predictions_Train_", param),
      seed=s, max_mem_size=max_mem_size, nthreads=nthreads
    ) %>% dplyr::mutate("DataType"="Train", "Parameter"=param)
    cat("Testing data. \n", sep="")
    df_pred_test_list[[i]] <- Immunogenicity_Prediction(
      dt[DataType=="Test",],
      destDir=modDir, H2OModelName=modName, PredictionHeader=paste0("Predictions_Test_", param),
      seed=s, max_mem_size=max_mem_size, nthreads=nthreads
    ) %>% dplyr::mutate("DataType"="Test", "Parameter"=param)
    cat("Validation data. \n", sep="")
    df_pred_valid_list[[i]] <- Immunogenicity_Prediction(
      dt[DataType=="Valid",],
      destDir=modDir, H2OModelName=modName, PredictionHeader=paste0("Predictions_Valid_", param),
      seed=s, max_mem_size=max_mem_size, nthreads=nthreads
    ) %>% dplyr::mutate("DataType"="Valid", "Parameter"=param)

    ## Closing
    invisible(h2o::h2o.shutdown(F))
  }

  # Outputs
  df_lb <- data.table::rbindlist(df_lb_list)
  readr::write_csv(df_lb, file.path(destDir, paste0(outputHeader, "LeaderBoard.csv")))
  df_pred <- data.table::rbindlist(list(
    data.table::rbindlist(df_pred_train_list),
    data.table::rbindlist(df_pred_test_list),
    data.table::rbindlist(df_pred_valid_list)
  ))
  readr::write_csv(df_pred, file.path(destDir, paste0(outputHeader, "Predictions.csv")))
  gc();gc()
  return(list("LeaderBoard"=df_lb, "Predictions"=df_pred))
}

#' @export
#' @rdname ImmunogenicityPrediction
#' @name ImmunogenicityPrediction
Immunogenicity_AutoML <- function(
  trainDF, testDF, validDF, featureSet="all",
  destDir="./Results/", LeaderBoardName="LeaderBoard.csv", H2OModelName="BestH2OModel",
  seed=12345, max_mem_size="6G", nthreads=6
){
  # Working environment
  set.seed(seed)
  dir.create(destDir, showWarnings=F, recursive=T)
  h2o::h2o.init(ip="localhost", port=seed, max_mem_size=max_mem_size, nthreads=nthreads)
   ## Setting different ports using different seed numbers is important. Otherwise, h2o::h2o.automl incorporates classifiers constructed in previous iterations (with different random seeds!) for ensembling.

  # Level check
  trainDF$"Immunogenicity" <- factor(trainDF$"Immunogenicity", levels=c("Positive", "Negative"))
  testDF$"Immunogenicity" <- factor(testDF$"Immunogenicity", levels=c("Positive", "Negative"))
  validDF$"Immunogenicity" <- factor(validDF$"Immunogenicity", levels=c("Positive", "Negative"))

  # Down-sampling to minimize the effect of class imbalance
  trainDF <- caret::downSample(dplyr::select(trainDF, -Immunogenicity), trainDF$"Immunogenicity", yname="Immunogenicity") %>%
    dplyr::select(Immunogenicity, setdiff(colnames(.), "Immunogenicity"))

  # Train classifiers
  df_train <- h2o::as.h2o(trainDF)
  df_test <- h2o::as.h2o(testDF)
  df_valid <- h2o::as.h2o(validDF)
  if(identical(featureSet, "all")){
    featureSet <- setdiff(colnames(trainDF), c("DataType", "Immunogenicity", "Peptide", "Cluster"))
  }else{
    featureSet <- setdiff(as.character(as.vector(featureSet)), c("DataType", "Immunogenicity", "Peptide", "Cluster"))
  } ## remove metadata to avoid leakage
  aml <- h2o::h2o.automl(
    x=featureSet,
    y="Immunogenicity",
    training_frame=df_train,
    validation_frame=df_test,
    leaderboard_frame=df_valid,
    max_models=100,
    stopping_metric="AUC",
    stopping_tolerance=0.1,
    stopping_rounds=3,
    seed=seed,
    project_name=H2OModelName
  )
  df_lb <- as.data.frame(aml@leaderboard)
  if(!is.null(LeaderBoardName)) readr::write_csv(df_lb, file.path(destDir, LeaderBoardName))

  # Save the best classifier
  best_model_name <- df_lb[["model_id"]][[1]]
  best_model <- h2o::h2o.getModel(best_model_name)
  if(!is.null(H2OModelName)){
    h2o::h2o.saveModel(object=best_model, path=destDir, force=T)
    invisible(file.copy(
      from=file.path(destDir, best_model_name),
      to=file.path(destDir, H2OModelName),
      overwrite=T
    ))
    invisible(file.remove(file.path(destDir, best_model_name)))
  }

  # Output
  return(df_lb)
}

#' @export
#' @rdname ImmunogenicityPrediction
#' @name ImmunogenicityPrediction
Immunogenicity_Prediction <- function(
  evalDF, destDir="./Results/", H2OModelName="BestH2OModel", PredictionHeader="Predictions",
  seed=12345, max_mem_size="6G", nthreads=6
){
  # Working environment
  set.seed(seed)
  dir.create(destDir, showWarnings=F, recursive=T)
  h2o::h2o.init(ip="localhost", port=seed, max_mem_size=max_mem_size, nthreads=nthreads)

  # Immunogenicity prediction
  evalH2ODF <- h2o::as.h2o(evalDF)
  H2OMod <- h2o::h2o.loadModel(file.path(destDir, H2OModelName))
  predDF <- as.data.frame(predict(H2OMod, evalH2ODF))
  colnames(predDF)[1] <- "PredictedImmunogenicity"
  predDF <- dplyr::bind_cols(dplyr::select(evalDF, c("Peptide", "Immunogenicity")), predDF)

  # Probability distribution plot
  thr <- pROC::coords(pROC::roc(predDF$"Immunogenicity", predDF$"Positive"), "b", ret="t", best.method="youden")[1] ## Two or more threshold could sometimes be returned... The first one is the lowest, meaning maximum sensitivity for P.aeruginosa.
  probPlot <- ggplot(data=predDF, aes_string(x="Immunogenicity", y="Positive")) +
    geom_violin(trim=F) +
    stat_summary(fun.data=mean_sdl, geom="pointrange", color="red") +
    geom_hline(yintercept=thr, color="grey50", size=1) +
    xlab(NULL) + ylab("Immunogenicity score") +
    plotUtility::theme_Publication(base_size=14)
  plotUtility::savePDF(probPlot, outputFileName=file.path(destDir, paste0(PredictionHeader, "_ViolinPlot.pdf")), width=5, height=5)

  # Classifier performance plots
  rocPlot <- classifierplots::roc_plot(2-as.numeric(predDF$"Immunogenicity"), predDF$"Positive") +
    plotUtility::theme_Publication(base_size=14)
  plotUtility::savePDF(rocPlot, outputFileName=file.path(destDir, paste0(PredictionHeader, "_ROCPlot.pdf")), width=5, height=5)
  calibPlot <- classifierplots::calibration_plot(2-as.numeric(predDF$"Immunogenicity"), predDF$"Positive") +
    plotUtility::theme_Publication(base_size=14)
  plotUtility::savePDF(calibPlot, outputFileName=file.path(destDir, paste0(PredictionHeader, "_CalibrationPlot.pdf")), width=5, height=5)

  # Output
  return(predDF)
}
