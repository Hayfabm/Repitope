#' Immune transition score.
#'
#' \code{ImmuneTransition_TrainModels} performes preprocessing, trains extremely randomized tree models, and internally predicts immune transition scores on the entire dataset provided.\cr
#' \code{ImmuneTransition_SummarizeInternalScores} summarizes internally calculated immune transition scores.\cr
#' \code{ImmuneTransition_Score} is a wrapper function of \code{ImmuneTransition_TrainModels} and \code{ImmuneTransition_SummarizeInternalScores}.\cr
#' \code{ImmuneTransition_Predict} predicts immune transition scores on external datasets. Models trained by \code{ImmuneTransition_TrainModels} are necessary. Note that, due to Java constraints, models have to be constructed in each new R session.
#'
#' @param featureDF A dataframe of features generated by \code{Features}.
#' @param metadataDF A dataframe containing metadata, consisting of "Peptide" and "ImmuneTransition" columns. Other columns if provided would be used as features.
#' @param featureSet A set of features used for model training. Set "all" to shortcut.
#' @param seedSet A set of random seeds.
#' @param coreN The number of cores to be used for parallelization. Set \code{NULL} to disable.
#' @param trainModelResults The model training result returned by \code{ImmuneTransition_TrainModels}.
#' @param externalFeatureDFList The feature dataframes for which immune transition is to be predicted.
#' @export
#' @rdname ImmuneTransition
#' @name ImmuneTransition
ImmuneTransition_TrainModels <- function(
  featureDF,
  metadataDF,
  featureSet="all",
  seedSet=1:5,
  coreN=parallel::detectCores(logical=F)
){
  # A combined feature dataframe
  dt <- merge(data.table::as.data.table(metadataDF), data.table::as.data.table(featureDF), by="Peptide")
  if(identical(featureSet, "all")){
    featureSet <- setdiff(colnames(dt), c("Peptide", "ImmuneTransition"))
  }else{
    dt <- dt[, c("Peptide", "ImmuneTransition", featureSet), with=F]
  }
  dt[,"ImmuneTransition":=factor(ImmuneTransition, levels=c("T", "NT"))]

  # Random splitting
  trainIDList <- lapply(seedSet, function(s){set.seed(s);lapply(BBmisc::chunk(1:nrow(dt), n.chunks=5, shuffle=T), function(v){setdiff(1:nrow(dt), v)})})

  # The main workflow
  main <- function(dt, trainIDs){
    dt_train <- dt[trainIDs,]
    dt_test <- dt[-trainIDs,]
    pp_train <- caret::preProcess(dt_train[, featureSet, with=F], method=c("center", "scale"))
    dt_train <- predict(pp_train, dt_train)
    dt_test <- predict(pp_train, dt_test)
    trgt <- dt_train$"ImmuneTransition"
    tab <- as.numeric(table(trgt))
    w <- 1/tab[trgt]
    mat_train <- as.matrix(dt_train[, featureSet, with=F])
    ert <- extraTrees::extraTrees(
      x=mat_train, y=trgt,
      mtry=35, numRandomCuts=2, weights=w,
      numThreads=ifelse(is.null(coreN), 1, coreN)
    )
    mat_test <- as.matrix(dt_test[, featureSet, with=F])
    predDT <- data.table::data.table("Peptide"=dt_test$"Peptide")
    predDT[,ImmuneTransitionScore:=predict(ert, mat_test, probability=T)[,"T"]]
    return(list(
      "pp_train"=pp_train, "ert"=ert, "predDT"=predDT
    ))
  }
  resList <- foreach::foreach(i=1:length(seedSet))%do%{
    cat("Random seed = ", seedSet[i], "\n", sep="")
    pbapply::pblapply(trainIDList[[i]], function(trainIDs){main(dt, trainIDs)})
  }
  return(list("TrainModelResults"=resList, "FeatureSet"=featureSet, "SeedSet"=seedSet))
}

#' @export
#' @rdname ImmuneTransition
#' @name ImmuneTransition
ImmuneTransition_SummarizeInternalScores <- function(trainModelResults){
  dt_score <- lapply(trainModelResults$"TrainModelResults", function(res){lapply(res, function(r){r$"predDT"})}) %>%
    purrr::flatten() %>%
    data.table::rbindlist()
  dt_score <- dt_score[, list(ImmuneTransitionScore.ave=mean(ImmuneTransitionScore), ImmuneTransitionScore.sd=sd(ImmuneTransitionScore)), by=Peptide]
  dt_score <- dt_score[, ImmuneTransitionScore:=ImmuneTransitionScore.ave]
  dt_score <- dt_score[, ImmuneTransitionScore.cv:=ImmuneTransitionScore.sd/ImmuneTransitionScore.ave]
  dt_score <- dt_score[, c("Peptide", "ImmuneTransitionScore", "ImmuneTransitionScore.cv"), with=F]
  return(dt_score)
}

#' @export
#' @rdname ImmuneTransition
#' @name ImmuneTransition
ImmuneTransition_Score <- function(
  featureDF,
  metadataDF,
  featureSet="all",
  seedSet=1:5,
  coreN=parallel::detectCores(logical=F)
){
  trainModelResults <- ImmuneTransition_TrainModels(featureDF, metadataDF, featureSet, seedSet, coreN)
  dt_score <- ImmuneTransition_SummarizeInternalScores(trainModelResults)
  return(dt_score)
}

#' @export
#' @rdname ImmuneTransition
#' @name ImmuneTransition
ImmuneTransition_Predict <- function(externalFeatureDFList, trainModelResults){
  featureSet <- trainModelResults$"FeatureSet"
  pp_list <- purrr::flatten(
    lapply(trainModelResults$"TrainModelResults", function(res){lapply(res, function(r){r$"pp_train"})})
  )
  ert_list <- purrr::flatten(
    lapply(trainModelResults$"TrainModelResults", function(res){lapply(res, function(r){r$"ert"})})
  )
  scoreDT_list <- foreach::foreach(i=1:length(externalFeatureDFList))%do%{
    cat("Data set #", i, "\n", sep="")
    dt <- data.table::as.data.table(externalFeatureDFList[[i]])
    dt_score <- pbapply::pblapply(1:length(pp_list), function(j){
      mat <- as.matrix(predict(pp_list[[j]], dt[, featureSet, with=F]))
      predDT <- data.table::data.table("Peptide"=dt$"Peptide")
      predDT[,ImmuneTransitionScore:=predict(ert_list[[j]], mat, probability=T)[,"T"]]
      return(predDT)
    }) %>%
      data.table::rbindlist()
    dt_score <- dt_score[, list(ImmuneTransitionScore.ave=mean(ImmuneTransitionScore), ImmuneTransitionScore.sd=sd(ImmuneTransitionScore)), by=Peptide]
    dt_score <- dt_score[, ImmuneTransitionScore:=ImmuneTransitionScore.ave]
    dt_score <- dt_score[, ImmuneTransitionScore.cv:=ImmuneTransitionScore.sd/ImmuneTransitionScore.ave]
    dt_score <- dt_score[, c("Peptide", "ImmuneTransitionScore", "ImmuneTransitionScore.cv"), with=F]
    return(dt_score)
  }
  return(scoreDT_list)
}
