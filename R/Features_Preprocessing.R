#' Preprocess peptide feature dataframes for machine learning.
#'
#' @param featureDFList A list of feature dataframes generated by \code{Features}.
#' @param metadataDFList A list of metadata dataframes labeled as "Peptide", "Immunogenicity", and "Cluster". No extra metadata is allowed. Feature dataframes are downsized based on the "Peptide" column in this metadata. In other words, peptides not contained in the metadata dataframe are omitted.
#' @param preprocessedDFList A list of feature dataframes generated by \code{Features_Preprocess} or \code{Features_CorFilter}.
#' @param corThreshold The threshold for correlation-based feature elimination.
#' @param featureN The number of the features that should be retained.
#' @param coreN The number of cores to be used for parallelization. Set \code{NULL} to skip parallelization.
#' @importFrom stringr str_split
#' @importFrom stringr fixed
#' @importFrom dplyr %>%
#' @importFrom dplyr distinct
#' @importFrom dplyr filter
#' @importFrom dplyr mutate
#' @importFrom dplyr left_join
#' @importFrom dplyr select
#' @importFrom tidyr drop_na
#' @importFrom data.table as.data.table
#' @importFrom data.table :=
#' @importFrom data.table setcolorder
#' @importFrom data.table setorder
#' @importFrom parallel detectCores
#' @importFrom parallel splitIndices
#' @importFrom parallel detectCores
#' @importFrom parallel makeCluster
#' @importFrom parallel clusterEvalQ
#' @importFrom parallel clusterExport
#' @importFrom parallel stopCluster
#' @importFrom doParallel registerDoParallel
#' @importFrom pbapply pbapply
#' @importFrom pbapply pblapply
#' @importFrom foreach foreach
#' @importFrom foreach %do%
#' @importFrom caret createDataPartition
#' @importFrom caret preProcess
#' @importFrom caret findCorrelation
#' @importFrom caret sbfControl
#' @importFrom caret sbf
#' @importFrom caret rfSBF
#' @importFrom caret rfeControl
#' @importFrom caret rfe
#' @importFrom caret rfFuncs
#' @importFrom caret predictors
#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_Preprocess <- function(featureDFList, metadataDFList){
  Features_Preprocess_Single <- function(featureDF, metadataDF, seed=12345){
    # Combine metadata
    dt <- merge(data.table::as.data.table(metadataDF), data.table::as.data.table(featureDF), by="Peptide")
    dt <- tidyr::drop_na(dt)
    dt[, Immunogenicity:=factor(Immunogenicity, levels=c("Positive", "Negative"))]

    # Randomly choose one epitope per each cluster [Minor class is prioritized]
    set.seed(seed)
    outcome_table <- table(dt$"Immunogenicity")
    if(outcome_table["Positive"]>=outcome_table["Negative"]){
      outcome_minor_major <- c("Negative", "Positive")
    }else{
      outcome_minor_major <- c("Positive", "Negative")
    }
    dt <- dt[sample.int(nrow(dt)),]
    dt[, Immunogenicity:=factor(Immunogenicity, levels=outcome_minor_major)]
    dt <- dplyr::distinct(dt, Immunogenicity, Cluster, .keep_all=T)
    dt <- dplyr::distinct(dt, Cluster, .keep_all=T)
    dt <- dplyr::distinct(dt, Peptide, .keep_all=T)
    data.table::setorder(dt, Peptide, Cluster)
    dt[, Immunogenicity:=factor(Immunogenicity, levels=c("Positive", "Negative"))]

    # Random data splitting [train:test=7:3]
    set.seed(seed)
    dataTypes <- rep("Test", nrow(dt))
    dataTypes[caret::createDataPartition(dt$"Immunogenicity", p=7/10, list=F)] <- "Train"
    dataTypes <- factor(dataTypes, levels=c("Train", "Test"))
    dt[, DataType:=dataTypes]
    data.table::setcolorder(dt, unique(c("DataType", colnames(dt))))

    # Rescaling
    metadataSet <- c("DataType", "Peptide", "Immunogenicity", "Cluster")
    featureSet <- setdiff(colnames(dt), metadataSet)
    dummyFeatureSet <- grep("Peptide_", featureSet, value=T)
    pp_train <- caret::preProcess(
      dplyr::select(dt, setdiff(featureSet, dummyFeatureSet)),
      method=c("center", "scale"), verbose=F
    )
    dt <- data.table::as.data.table(predict(pp_train, dt))

    # Output
    rm(list=setdiff(ls(), c("dt", "pp_train")))
    gc();gc()
    list("dt"=dt, "pp_train"=pp_train)
  }
  message("Preprocessing...")
  paramDF <- expand.grid(names(metadataDFList), names(featureDFList), stringsAsFactors=F)
  conbinedParamSet <- apply(paramDF, 1, function(v){paste0(v, collapse=".")})
  preprocessedDFList <- pbapply::pbapply(
    paramDF, 1,
    function(v){
      s <- as.numeric(as.character(rev(unlist(stringr::str_split(v[[2]], stringr::fixed("."))))[1]))
      Features_Preprocess_Single(featureDFList[[v[2]]], metadataDFList[[v[1]]], s)
    }
  )
  names(preprocessedDFList) <- conbinedParamSet
  return(preprocessedDFList)
}

#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_CorFilter <- function(preprocessedDFList, corThreshold=0.75, coreN=parallel::detectCores()){
  Features_CorFilter_Single <- function(df, corThreshold=0.75, coreN=NULL){
    # Correlation-based feature elimination using the training subdataset
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ]
    metadataSet <- c("DataType", "Peptide", "Immunogenicity", "Cluster")
    dt.meta <- dt[, c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    message("Calculating correlation matrix...")
    if(!is.null(coreN)){
      corMat <- parCor(dt, num_splits=coreN, verbose=2)
    }else{
      corMat <- parCor(dt, num_splits=1, verbose=2)
    }
    removedFeatureSet <- caret::findCorrelation(corMat, cutoff=corThreshold, verbose=F, names=T)
    if(length(removedFeatureSet)>0) dt <- dt[, -removedFeatureSet, with=F]
    message(length(removedFeatureSet), " features were removed based on their correlations.")
    dt <- data.table::rbindlist(list(dt.meta, dt))

    # Output
    rm(list=setdiff(ls(), "dt"))
    gc();gc()
    return(list("dt"=dt))
  }
  message("Correlation-based feature elimination.")
  time.start <- proc.time()
  conbinedParamSet <- names(preprocessedDFList)
  preprocessedDFList <- foreach::foreach(i=1:length(conbinedParamSet))%do%{
    cat(i, "/", length(conbinedParamSet), ": ", conbinedParamSet[i], "\n", sep="")
    Features_CorFilter_Single(preprocessedDFList[[i]][["dt"]], corThreshold=corThreshold, coreN=coreN)
  }
  names(preprocessedDFList) <- conbinedParamSet
  time.end <- proc.time()
  message("Overall time required = ", format((time.end-time.start)[3], nsmall=2), "[sec]")
  return(preprocessedDFList)
}

#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_FeatureSelect <- function(preprocessedDFList, featureN=100, coreN=parallel::detectCores()){
  # Selection by filtering
  Features_SBF_Single <- function(df, seed=12345, coreN=NULL){
    caretSeeds_SBF <- function(seed=12345, number=5){
      set.seed(seed)
      seeds <- sample.int(10000, number+1)
      return(seeds)
    }
    message("Selection by filtering.")
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ,]
    outcomes <- dt$"Immunogenicity"
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    sbfCtrl <- caret::sbfControl(
      functions=caret::rfSBF,
      method="cv", number=5, seeds=caretSeeds_SBF(seed=seed, number=5),
      verbose=T, allowParallel=T
    )
    if(!is.null(coreN)){
      cl <- parallel::makeCluster(coreN, type='SOCK')
      parallel::clusterExport(
        cl,
        list("dt", "outcomes", "sbfCtrl"),
        envir=environment()
      )
      doParallel::registerDoParallel(cl)
      sbfRes <- caret::sbf(
        dt, as.numeric(outcomes), sbfControl=sbfCtrl
      )
      parallel::stopCluster(cl)
    }else{
      sbfRes <- caret::sbf(
        dt, as.numeric(outcomes), sbfControl=sbfCtrl
      )
    }
    sbfFeatureSet <- caret::predictors(sbfRes)
    sbfFeatureSet <- c("DataType", "Peptide", "Immunogenicity", "Cluster", sbfFeatureSet)
    dt <- data.table::as.data.table(df)
    message(length(setdiff(colnames(dt), sbfFeatureSet)), " features were removed.")
    dt <- dt[, sbfFeatureSet, with=F]

    # Output
    rm(list=setdiff(ls(), c("dt", "sbfRes")))
    gc();gc()
    list("dt"=dt, "sbfRes"=sbfRes)
  }

  # Recursive feature elimination
  Features_RFE_Single <- function(df, sizes=100, seed=12345, coreN=NULL){
    caretSeeds_RFE <- function(seed=12345, number=10){
      set.seed(seed)
      seeds <- vector(mode="list", length=number+1)
      for(i in 1:(number)) seeds[[i]] <- sample.int(10000, 2)
      seeds[[number+1]] <- sample.int(10000, 1)
      return(seeds)
    }
    message("Recursive feature elimination.")
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ,]
    outcomes <- dt$"Immunogenicity"
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    rfeCtrl <- caret::rfeControl(
      functions=caret::rfFuncs, rerank=F,
      method="cv", number=5, seeds=caretSeeds_RFE(seed=seed, number=5),
      verbose=T, allowParallel=T
    )
    if(!is.null(coreN)){
      cl <- parallel::makeCluster(coreN, type='SOCK')
      parallel::clusterExport(
        cl,
        list("dt", "outcomes", "rfeCtrl"),
        envir=environment()
      )
      doParallel::registerDoParallel(cl)
      rfeRes <- caret::rfe(
        dt, outcomes, sizes=sizes, metric="Kappa", rfeControl=rfeCtrl
      )
      parallel::stopCluster(cl)
    }else{
      rfeRes <- caret::rfe(
        dt, outcomes, sizes=sizes, metric="Kappa", rfeControl=rfeCtrl
      )
    }
    rfeFeatureSet <- caret::predictors(rfeRes)
    rfeFeatureSet <- c("DataType", "Peptide", "Immunogenicity", "Cluster", rfeFeatureSet)
    dt <- data.table::as.data.table(df)
    message(length(setdiff(colnames(dt), rfeFeatureSet)), " features were removed.")
    dt <- dt[, rfeFeatureSet, with=F]

    # Output
    rm(list=setdiff(ls(), c("dt", "rfeRes")))
    gc();gc()
    list("dt"=dt, "rfeRes"=rfeRes)
  }

  # Main workflow
  message("Feature selection...")
  time.start <- proc.time()
  conbinedParamSet <- names(preprocessedDFList)
  preprocessedDFList <- foreach::foreach(i=1:length(conbinedParamSet))%do%{
    cat(i, "/", length(conbinedParamSet), ": ", conbinedParamSet[i], "\n", sep="")
    seed <- as.numeric(as.character(rev(unlist(stringr::str_split(conbinedParamSet[i], stringr::fixed("."))))[1]))
    res <- list(
      "dt"=preprocessedDFList[[i]][["dt"]],
      "sbfRes"=NULL,
      "rfeRes"=NULL
    )
    res <- modifyList(res, Features_SBF_Single(res$"dt", seed=seed, coreN=coreN))
    if(length(setdiff(colnames(res$"dt"), c("DataType", "Peptide", "Immunogenicity", "Cluster")))>featureN){
      res <- modifyList(res, Features_RFE_Single(res$"dt", sizes=featureN, seed=seed, coreN=coreN))
    }
    res
  }
  names(preprocessedDFList) <- conbinedParamSet
  time.end <- proc.time()
  message("Overall time required = ", format((time.end-time.start)[3], nsmall=2), "[sec]")
  return(preprocessedDFList)
}
