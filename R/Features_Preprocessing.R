#' Preprocess peptide feature dataframes for machine learning.
#'
#' @param featureDFList A list of feature dataframes generated by \code{Features}.
#' @param metadataDFList A list of metadata dataframes labeled as "Peptide", "Immunogenicity", and "Cluster". No extra metadata is allowed. Feature dataframes are downsized based on the "Peptide" column in this metadata. In other words, peptides not contained in the metadata dataframe are omitted.
#' @param preprocessedDTList A list of feature dataframes generated by \code{Features_Preprocess}.
#' @param corfilterDTList A list of feature dataframes generated by \code{Features_CorFilter}.
#' @param corThreshold The threshold for correlation-based feature elimination.
#' @param coreN The number of cores to be used for parallelization. Set \code{NULL} to skip parallelization.
#' @importFrom stringr str_split
#' @importFrom stringr fixed
#' @importFrom dplyr %>%
#' @importFrom dplyr distinct
#' @importFrom dplyr filter
#' @importFrom dplyr mutate
#' @importFrom dplyr left_join
#' @importFrom dplyr select
#' @importFrom tidyr drop_na
#' @importFrom data.table as.data.table
#' @importFrom data.table :=
#' @importFrom data.table setcolorder
#' @importFrom data.table setorder
#' @importFrom parallel detectCores
#' @importFrom parallel splitIndices
#' @importFrom parallel detectCores
#' @importFrom parallel makeCluster
#' @importFrom parallel clusterEvalQ
#' @importFrom parallel clusterExport
#' @importFrom parallel stopCluster
#' @importFrom doParallel registerDoParallel
#' @importFrom pbapply pbapply
#' @importFrom pbapply pblapply
#' @importFrom foreach foreach
#' @importFrom foreach %do%
#' @import caret
#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_Preprocess <- function(featureDFList, metadataDFList){
  Features_Preprocess_Single <- function(featureDF, metadataDF, seed=12345){
    # Combine metadata
    dt <- merge(data.table::as.data.table(metadataDF), data.table::as.data.table(featureDF), by="Peptide")
    dt <- tidyr::drop_na(dt)
    dt[, Immunogenicity:=factor(Immunogenicity, levels=c("Positive", "Negative"))]

    # Randomly choose one epitope per each cluster [Minor class is prioritized]
    set.seed(seed)
    outcome_table <- table(dt$"Immunogenicity")
    if(outcome_table["Positive"]>=outcome_table["Negative"]){
      outcome_minor_major <- c("Negative", "Positive")
    }else{
      outcome_minor_major <- c("Positive", "Negative")
    }
    dt <- dt[sample.int(nrow(dt)),]
    dt[, Immunogenicity:=factor(Immunogenicity, levels=outcome_minor_major)]
    dt <- dplyr::distinct(dt, Immunogenicity, Cluster, .keep_all=T)
    dt <- dplyr::distinct(dt, Cluster, .keep_all=T)
    dt <- dplyr::distinct(dt, Peptide, .keep_all=T)
    data.table::setorder(dt, Peptide, Cluster)
    dt[, Immunogenicity:=factor(Immunogenicity, levels=c("Positive", "Negative"))]

    # Random data splitting [train:test=7:3]
    set.seed(seed)
    dataTypes <- rep("Test", nrow(dt))
    dataTypes[caret::createDataPartition(dt$"Immunogenicity", p=7/10, list=F)] <- "Train"
    dataTypes <- factor(dataTypes, levels=c("Train", "Test"))
    dt[, DataType:=dataTypes]
    data.table::setcolorder(dt, unique(c("DataType", colnames(dt))))

    # Rescaling
    metadataSet <- c("DataType", "Peptide", "Immunogenicity", "Cluster")
    featureSet <- setdiff(colnames(dt), metadataSet)
    dummyFeatureSet <- grep("Peptide_", featureSet, value=T)
    pp_train <- caret::preProcess(
      dplyr::select(dt, setdiff(featureSet, dummyFeatureSet)),
      method=c("center", "scale"), verbose=F
    )
    dt <- data.table::as.data.table(predict(pp_train, dt))

    # Output
    gc();gc()
    list("dt"=dt, "pp_train"=pp_train)
  }
  message("Preprocessing...")
  paramDF <- expand.grid(names(metadataDFList), names(featureDFList), stringsAsFactors=F)
  conbinedParamSet <- apply(paramDF, 1, function(v){paste0(v, collapse=".")})
  preprocessedDTList <- pbapply::pbapply(
    paramDF, 1,
    function(v){
      s <- as.numeric(as.character(rev(unlist(stringr::str_split(v[[2]], stringr::fixed("."))))[1]))
      Features_Preprocess_Single(featureDFList[[v[2]]], metadataDFList[[v[1]]], s)
    }
  )
  names(preprocessedDTList) <- conbinedParamSet
  return(preprocessedDTList)
}

#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_CorFilter <- function(preprocessedDTList, corThreshold=0.75, coreN=parallel::detectCores()){
  Features_CorFilter_Single <- function(df, corThreshold=0.75, coreN=NULL){
    # Correlation-based feature elimination using the training subdataset
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ]
    metadataSet <- c("DataType", "Peptide", "Immunogenicity", "Cluster")
    dt.meta <- dt[, c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    message("Calculating correlation matrix...")
    if(!is.null(coreN)){
      corMat <- parCor(dt, num_splits=coreN, verbose=2)
    }else{
      corMat <- parCor(dt, num_splits=1, verbose=2)
    }
    removedFeatureSet <- caret::findCorrelation(corMat, cutoff=corThreshold, verbose=F, names=T)
    if(length(removedFeatureSet)>0) dt <- dt[, -removedFeatureSet, with=F]
    message(length(removedFeatureSet), " features were removed based on their correlations.")
    dt <- data.table::rbindlist(list(dt.meta, dt))

    # Output
    gc();gc()
    return(dt)
  }
  message("Correlation-based feature elimination.")
  time.start <- proc.time()
  conbinedParamSet <- names(preprocessedDTList)
  corfilteredDTList <- foreach::foreach(i=1:length(conbinedParamSet))%do%{
    cat(i, "/", length(conbinedParamSet), ": ", conbinedParamSet[i], "\n", sep="")
    Features_CorFilter_Single(preprocessedDTList[[i]][["dt"]], corThreshold=corThreshold, coreN=coreN)
  }
  names(corfilteredDTList) <- conbinedParamSet
  time.end <- proc.time()
  message("Overall time required = ", format((time.end-time.start)[3], nsmall=2), "[sec]")
  return(corfilteredDTList)
}

#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_FeatureSelection <- function(corfilteredDTList, coreN=parallel::detectCores()){
  # A random seed generator
  caretSeeds_SBF <- function(seed, number=10, repeats=5){
    set.seed(seed)
    seeds <- sample.int(10000, number*repeats+1)
    return(seeds)
  }
  caretSeeds_RFE <- function(seed, number=10, repeats=5){
    set.seed(seed)
    seeds <- vector(mode="list", length=number*repeats+1)
    for(i in 1:(number*repeats)) seeds[[i]] <- sample.int(10000, 2)
    seeds[[number*repeats+1]] <- sample.int(10000, 1)
    return(seeds)
  }

  # Selection by filtering
  Features_SBF_Single <- function(df, seeds, coreN=NULL){
    message("Selection by filtering.")
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ,]
    outcomes <- dt$"Immunogenicity"
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    sbfCtrl <- caret::sbfControl(
      functions=caret::lmSBF,
      method="repeatedcv", number=10, repeats=5,
      verbose=T, seeds=seeds, allowParallel=T
    )
    if(!is.null(coreN)){
      cl <- parallel::makeCluster(coreN, type='SOCK')
      parallel::clusterExport(
        cl,
        list("dt", "outcomes", "sbfCtrl"),
        envir=environment()
      )
      doParallel::registerDoParallel(cl)
      sbfRes <- caret::sbf(
        dt, as.numeric(outcomes), sbfControl=sbfCtrl
      )
      parallel::stopCluster(cl)
    }else{
      sbfRes <- caret::sbf(
        dt, as.numeric(outcomes), sbfControl=sbfCtrl
      )
    }
    sbfFeatureSet <- caret::predictors(sbfRes)
    sbfFeatureSet <- c("DataType", "Peptide", "Immunogenicity", "Cluster", sbfFeatureSet)
    dt <- data.table::as.data.table(df)
    message(length(setdiff(colnames(dt), sbfFeatureSet)), " features were removed.")
    dt <- dt[, sbfFeatureSet, with=F]

    # Output
    gc();gc()
    list("dt"=dt, "sbfRes"=sbfRes)
  }

  # Recursive feature elimination
  Features_RFE_Single <- function(df, sizes=50, seeds, coreN=NULL){
    message("Recursive feature elimination.")
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ,]
    outcomes <- dt$"Immunogenicity"
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    rfeCtrl <- caret::rfeControl(
      functions=caret::rfFuncs, rerank=F,
      method="repeatedcv", number=10, repeats=5,
      verbose=T, seeds=seeds, allowParallel=T
    )
    if(!is.null(coreN)){
      cl <- parallel::makeCluster(coreN, type='SOCK')
      parallel::clusterExport(
        cl,
        list("dt", "outcomes", "rfeCtrl"),
        envir=environment()
      )
      doParallel::registerDoParallel(cl)
      rfeRes <- caret::rfe(
        dt, outcomes, sizes=sizes, metric="Kappa", rfeControl=rfeCtrl
      )
      parallel::stopCluster(cl)
    }else{
      rfeRes <- caret::rfe(
        dt, outcomes, sizes=sizes, metric="Kappa", rfeControl=rfeCtrl
      )
    }
    rfeFeatureSet <- caret::predictors(rfeRes)
    rfeFeatureSet <- c("DataType", "Peptide", "Immunogenicity", "Cluster", rfeFeatureSet)
    dt <- data.table::as.data.table(df)
    message(length(setdiff(colnames(dt), rfeFeatureSet)), " features were removed.")
    dt <- dt[, rfeFeatureSet, with=F]

    # Output
    gc();gc()
    list("dt"=dt, "rfeRes"=rfeRes)
  }

  # Main workflow
  message("Feature selection...")
  time.start <- proc.time()
  conbinedParamSet <- names(corfilteredDFList)
  caretSeedsList_SBF <- foreach::foreach(param=conbinedParamSet) %do% {
    s <- as.numeric(as.character(rev(unlist(stringr::str_split(param, stringr::fixed("."))))[1]))
    caretSeeds_SBF(s, number=10, repeats=5)
  }
  caretSeedsList_RFE <- foreach::foreach(param=conbinedParamSet) %do% {
    s <- as.numeric(as.character(rev(unlist(stringr::str_split(param, stringr::fixed("."))))[1]))
    caretSeeds_RFE(s, number=10, repeats=5)
  }
  preprocessedDTList <- foreach::foreach(i=1:length(conbinedParamSet)) %do% {
    cat(i, "/", length(conbinedParamSet), ": ", conbinedParamSet[i], "\n", sep="")
    res <- list(
      "dt"=corfilteredDFList[[i]][["dt"]],
      "pp_train"=corfilteredDFList[[i]][["pp_train"]],
      "sbfRes"=NULL,
      "rfeRes"=NULL
    )
    res <- modifyList(res, Features_SBF_Single(
      res$"dt",
      seeds=caretSeedsList_SBF[[i]],
      coreN=coreN
    ))
    if(ncol(res$"dt")>=55){
      res <- modifyList(res, Features_RFE_Single(
        res$"dt", sizes=50,
        seeds=caretSeedsList_RFE[[i]],
        coreN=coreN
      ))
    }
    res
  }
  names(preprocessedDTList) <- conbinedParamSet
  time.end <- proc.time()
  message("Overall time required = ", format((time.end-time.start)[3], nsmall=2), "[sec]")
  return(preprocessedDTList)
}
