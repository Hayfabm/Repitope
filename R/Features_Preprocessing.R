#' Preprocess peptide feature dataframes for machine learning.
#'
#' @param featureDFList A list of feature dataframes generated by \code{Features}.
#' @param metadataDFList A list of metadata dataframes labeled as "Peptide", "Immunogenicity", and "Cluster". No extra metadata is allowed. Feature dataframes are downsized based on the "Peptide" column in this metadata. In other words, peptides not contained in the metadata dataframe are omitted.
#' @param splitDFList A list of feature dataframes generated by \code{Features_SplitDF}.
#' @param preprocessedDFList A list of feature dataframes generated by \code{Features_Preprocess}.
#' @param preprocessedDFList_reference A list of feature dataframes generated by \code{Features_Preprocess} or \code{Features_RFE} for reference.
#' @param coreN The number of cores to be used for parallelization. Set \code{NULL} to skip parallelization.
#' @importFrom stringr str_split
#' @importFrom stringr fixed
#' @importFrom dplyr %>%
#' @importFrom dplyr distinct
#' @importFrom dplyr filter
#' @importFrom dplyr mutate
#' @importFrom dplyr left_join
#' @importFrom dplyr select
#' @importFrom tidyr drop_na
#' @importFrom data.table as.data.table
#' @importFrom data.table :=
#' @importFrom data.table setcolorder
#' @importFrom data.table setorder
#' @importFrom parallel detectCores
#' @importFrom parallel splitIndices
#' @importFrom parallel detectCores
#' @importFrom parallel makeCluster
#' @importFrom parallel clusterEvalQ
#' @importFrom parallel clusterExport
#' @importFrom parallel stopCluster
#' @importFrom doParallel registerDoParallel
#' @importFrom pbapply pbapply
#' @importFrom pbapply pblapply
#' @importFrom foreach foreach
#' @importFrom foreach %do%
#' @import caret
#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_Preprocess_ByReference <- function(featureDFList, metadataDFList, preprocessedDFList_reference){
  paramDF <- expand.grid(names(metadataDFList), names(featureDFList), stringsAsFactors=F)
  conbinedParamSet <- apply(paramDF, 1, function(v){paste0(v, collapse=".")})
  if(length(conbinedParamSet)!=length(preprocessedDFList_reference)){
    message("length(preprocessedDFList_reference) must be equal to length(featureDFList)*length(metadataDFList) !")
    return(NULL)
  }
  preprocessedDFList <- pbapply::pblapply(1:length(preprocessedDFList_reference), function(i){
    featureSet_reference <- colnames(preprocessedDFList_reference[[i]][["df_train"]])
    pp <- preprocessedDFList_reference[[i]][["pp_train"]]
    f <- featureDFList[[paramDF[[2]][[i]]]]
    m <- featureDFList[[paramDF[[1]][[i]]]]
    d <- dplyr::left_join(m, f, by="Peptide") %>%
      tidyr::drop_na() %>%
      dplyr::mutate(Immunogenicity=factor(Immunogenicity, levels=c("Positive", "Negative")))
    d.pp <- dplyr::select(d, featureSet_reference)
    d.pp <- predict(pp, d.pp)
    return(d.pp)
  })
  names(preprocessedDFList) <- conbinedParamSet
  gc();gc()
  return(preprocessedDFList)
}

#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_SplitDF <- function(featureDFList, metadataDFList){
  Features_Split_Single <- function(featureDF, metadataDF, seed=12345){
    # Combine metadata
    dt <- merge(data.table::as.data.table(metadataDF), data.table::as.data.table(featureDF), by="Peptide")
    dt <- tidyr::drop_na(dt)
    dt[, Immunogenicity:=factor(Immunogenicity, levels=c("Positive", "Negative"))]

    # Randomly choose one epitope per each cluster [Minor class is prioritized]
    set.seed(seed)
    outcome_table <- table(dt$"Immunogenicity")
    if(outcome_table["Positive"]>=outcome_table["Negative"]){
      outcome_minor_major <- c("Negative", "Positive")
    }else{
      outcome_minor_major <- c("Positive", "Negative")
    }
    dt <- dt[sample.int(nrow(dt)),]
    dt[, Immunogenicity:=factor(Immunogenicity, levels=outcome_minor_major)]
    dt <- dplyr::distinct(dt, Immunogenicity, Cluster, .keep_all=T)
    dt <- dplyr::distinct(dt, Cluster, .keep_all=T)
    dt <- dplyr::distinct(dt, Peptide, .keep_all=T)
    data.table::setorder(dt, Peptide, Cluster)
    dt[, Immunogenicity:=factor(Immunogenicity, levels=c("Positive", "Negative"))]

    # Random data splitting [train:test=7:3]
    set.seed(seed)
    dataTypes <- rep("Test", nrow(dt))
    dataTypes[caret::createDataPartition(dt$"Immunogenicity", p=7/10, list=F)] <- "Train"
    dataTypes <- factor(dataTypes, levels=c("Train", "Test"))
    dt[, DataType:=dataTypes]
    data.table::setcolorder(dt, unique(c("DataType", colnames(dt))))

    # Output
    gc();gc()
    return(dt)
  }
  message("Splitting dataframes...")
  paramDF <- expand.grid(names(metadataDFList), names(featureDFList), stringsAsFactors=F)
  conbinedParamSet <- apply(paramDF, 1, function(v){paste0(v, collapse=".")})
  splitDFList <- pbapply::pbapply(
    paramDF, 1,
    function(v){
      s <- as.numeric(as.character(rev(unlist(stringr::str_split(v[[2]], stringr::fixed("."))))[1]))
      Features_Split_Single(featureDFList[[v[2]]], metadataDFList[[v[1]]], s)
    }
  )
  names(splitDFList) <- conbinedParamSet
  return(splitDFList)
}

#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_Preprocess <- function(splitDFList, coreN=parallel::detectCores()){
  Features_Preprocess_Single <- function(df, coreN=NULL){
    # Correlation-based feature elimination using the training subdataset
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ]
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    message("Correlation-based feature elimination.")
    if(!is.null(coreN)){
      corMat <- parCor(dt, num_splits=coreN, verbose=2)
    }else{
      corMat <- parCor(dt, num_splits=1, verbose=2)
    }
    removedFeatureSet <- caret::findCorrelation(corMat, cutoff=0.6, verbose=F, names=T)
    if(length(removedFeatureSet)>0) dt <- dt[, -removedFeatureSet, with=F]
    message(length(removedFeatureSet), " features were removed based on their correlations.")

    # Rescaling
    featureSet <- colnames(dt)
    dummyFeatureSet <- grep("Peptide_", colnames(dt), value=T)
    if(length(dummyFeatureSet)>0) dt <- dt[, -dummyFeatureSet, with=F]
    pp_train <- caret::preProcess(dt, method=c("center", "scale"), verbose=T)
    dt <- data.table::as.data.table(df)
    dt <- dt[, c("DataType", "Peptide", "Immunogenicity", "Cluster", featureSet), with=F]
    dt <- data.table::as.data.table(predict(pp_train, dt))

    # Output
    gc();gc()
    list("dt"=dt, "pp_train"=pp_train)
  }
  message("Preprocessing...")
  time.start <- proc.time()
  conbinedParamSet <- names(splitDFList)
  preprocessedDTList <- foreach::foreach(i=1:length(conbinedParamSet)) %do% {
    cat(i, "/", length(conbinedParamSet), ": ", conbinedParamSet[i], "\n", sep="")
    Features_Preprocess_Single(splitDFList[[i]], coreN=coreN)
  }
  names(preprocessedDTList) <- conbinedParamSet
  time.end <- proc.time()
  message("Overall time required = ", format((time.end-time.start)[3], nsmall=2), "[sec]")
  return(preprocessedDTList)
}

#' @export
#' @rdname Features_Preprocessing
#' @name Features_Preprocessing
Features_FeatureSelection <- function(preprocessedDFList, coreN=parallel::detectCores()){
  # A set of random seeds
  caretSeeds <- function(seed, number){
    set.seed(seed)
    seeds <- vector(mode="list", length=number+1)
    for(i in 1:number) seeds[[i]] <- sample.int(10000, 2)
    seeds[[number+1]] <- sample.int(10000, 1)
    return(seeds)
  }
  caretSeedsList <- foreach::foreach(param=conbinedParamSet) %do% {
    s <- as.numeric(as.character(rev(unlist(stringr::str_split(param, stringr::fixed("."))))[1]))
    caretSeeds(s, number=10)
  }

  # Selection by filtering
  Features_SBF_Single <- function(df, seeds, coreN=NULL){
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ,]
    outcomes <- dt$"Immunogenicity"
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    sbfCtrl <- caret::sbfControl(
      functions=caret::lmSBF,
      method="repeatedcv", number=10, repeats=5,
      verbose=T, seeds=seeds, allowParallel=T
    )
    if(!is.null(coreN)){
      cl <- parallel::makeCluster(coreN, type='SOCK')
      doParallel::registerDoParallel(cl)
      sbfRes <- caret::sbf(
        dt, outcomes, sbfControl=sbfCtrl
      )
      parallel::stopCluster(cl)
    }else{
      sbfRes <- caret::sbf(
        dt, outcomes, sbfControl=sbfCtrl
      )
    }
    sbfFeatureSet <- caret::predictors(sbfRes)
    dt <- data.table::as.data.table(df)
    dt <- dt[, c("DataType", "Peptide", "Immunogenicity", "Cluster", sbfFeatureSet), with=F]

    # Output
    gc();gc()
    list("dt"=dt, "sbfRes"=sbfRes)
  }

  # Simulated annealing
  Features_safs_Single <- function(df, seeds, coreN=NULL){
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ,]
    outcomes <- dt$"Immunogenicity"
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    safsCtrl <- caret::safsControl(
      functions=caret::caretSA,
      method="repeatedcv", number=10, repeates=5,
      verbose=T, seeds=seeds, allowParallel=T
    )
    if(!is.null(coreN)){
      cl <- parallel::makeCluster(coreN, type='SOCK')
      doParallel::registerDoParallel(cl)
      safsRes <- caret::safs(
        dt, outcomes,
        iters=100,
        safsControl=safsCtrl,
        method="lm"
      )
      parallel::stopCluster(cl)
    }else{
      safsRes <- caret::safs(
        dt, outcomes,
        iters=100,
        safsControl=safsCtrl,
        method="lm"
      )
    }
    safsFeatureSet <- caret::predictors(safsRes)
    dt <- data.table::as.data.table(df)
    dt <- dt[, c("DataType", "Peptide", "Immunogenicity", "Cluster", safsFeatureSet), with=F]

    # Output
    gc();gc()
    list("dt"=dt, "safsRes"=safsRes)
  }

  # Recursive feature elimination
  Features_RFE_Single <- function(df, seeds, coreN=NULL){
    dt <- data.table::as.data.table(df)
    dt <- dt[DataType=="Train", ,]
    outcomes <- dt$"Immunogenicity"
    dt <- dt[, -c("DataType", "Peptide", "Immunogenicity", "Cluster"), with=F]
    rfeCtrl <- caret::rfeControl(
      functions=caret::lmFuncs,
      method="repeatedcv", number=10, repeates=5,
      verbose=T, seeds=seeds, allowParallel=T
    )
    if(!is.null(coreN)){
      cl <- parallel::makeCluster(coreN, type='SOCK')
      doParallel::registerDoParallel(cl)
      rfeRes <- caret::rfe(
        dt, outcomes,
        sizes=100, metric="Kappa", rfeControl=rfeCtrl
      )
      parallel::stopCluster(cl)
    }else{
      rfeRes <- caret::rfe(
        dt, outcomes,
        sizes=100, metric="Kappa", rfeControl=rfeCtrl
      )
    }
    rfeFeatureSet <- caret::predictors(rfeRes)
    dt <- data.table::as.data.table(df)
    dt <- dt[, c("DataType", "Peptide", "Immunogenicity", "Cluster", rfeFeatureSet), with=F]

    # Output
    gc();gc()
    list("dt"=dt, "rfeRes"=rfeRes)
  }

  # Main workflow
  message("Feature selection...")
  time.start <- proc.time()
  conbinedParamSet <- names(preprocessedDFList)
  preprocessedDTList <- foreach::foreach(i=1:length(conbinedParamSet)) %do% {
    cat(i, "/", length(conbinedParamSet), ": ", conbinedParamSet[i], "\n", sep="")
    res <- list(
      "dt"=preprocessedDFList[[i]][["dt"]],
      "pp_train"=preprocessedDFList[[i]][["pp_train"]],
      "sbfRes"=NULL,
      "rfeRes"=NULL
    )
    message("Selection by filtering.")
    res <- modifyList(res, Features_SBF_Single(
      res$"dt",
      seeds=caretSeedsList[[i]],
      coreN=coreN
    ))
    message("Recursive feature elimination.")
    res <- modifyList(res, Features_RFE_Single(
      res$"dt",
      seeds=caretSeedsList[[i]],
      coreN=coreN
    ))
    res
  }
  names(preprocessedDTList) <- conbinedParamSet
  time.end <- proc.time()
  message("Overall time required = ", format((time.end-time.start)[3], nsmall=2), "[sec]")
  return(preprocessedDTList)
}
